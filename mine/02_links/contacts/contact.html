<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Contact</title>
    </head>
    <body>
        <!--это более правильно решение переходов по странице-->
        <h1 id="up">contact</h1>
        <a href="../index.html">index</a> <br>
        <!--это менее правильно решение переходов по странице-->
        <a href="#bottom">bottom</a>
        <p>Доброго времени суток, друзья!
        </p>
        <p>Хочу поделиться опытом по борьбе с PHPUnit/DbUnit в связке с MySQL. Далее небольшая предыстория.
        </p>
        <p>Краткая предыстория</p>
        <p>В процессе написания одного веб-приложения возникла необходимость тестировать код на PHP, интенсивно взаимодействующий с БД MySQL. В проекте в качестве фреймворка модульного тестирования использовался порт xUnit — PHPUnit. В результате было принято решение писать тесты для модулей, непосредственно взаимодействующих с базой, подцепив плагин PHPUnit/DbUnit. Дальше я расскажу о тех трудностях, которые возникли при написании тестов и о том, каким способом я их преодолел. В ответ же хотелось бы получить комментарии знающих людей относительно корректности моих решений.</p>
        <p>Как работает DbUnit</p>
        <p>Подпункт предназначен для тех, кто не знаком с методикой тестирования с использованием PHPUnit и/или DbUnit. Кому не интересно, смело можно переходить к следующему.</p>
        <p>Далее по тексту:</p>
        <p>тестовый класс — класс, содержащий код модульных тестов, наследник любой из реализаций PHPUnit::TestCase;</p>
        <p>тестируемый класс — класс, который необходимо протестировать.</p>
        <p>Так как подпункт для начинающих, то для начала будет рассмотрена процедура модульного тестирования обычных классов PHP, а потом описаны отличия при тестировании кода, взаимодействующего с БД.</p>
        <p>Тестирование обычных классов PHP</p>
        <p>Чтобы протестировать класс, написанный на PHP, с использованием фреймворка PHPUnit, необходимо создать тестовый класс, расширяющий базовый класс PHPUnit_Framework_TestCase. Затем создать в этом классе публичные методы, начинающиеся со слова test (если создать метод, который будет называться по-другому, он не будет автоматически вызван при прогоне тестов), и поместить в них код, выполняющий действия с объектами тестируемого класса и проверяющий результат. На этом можно закончить и скормить полученный класс phpunit, который, в свою очередь, последовательно вызовет все тестовые методы и любезно предоставит отчет об их работе. Однако в большинстве случаев в каждом из тестовых методов будет повторяющийся код, подготавливающий систему для работы с тестируемым объектом. Для того, чтобы избежать дублирования кода, в классе PHPUnit_Framework_TestCase созданы защищенные методы setUp и tearDown, имеющие пустую реализацию. Эти методы вызываются перед и после запуска очередного тестового метода соответственно и служат для подготовки системы к выполнению тестовых действий и очистки ее после завершения каждого теста. В тестовом классе, расширяющем PHPUnit_Framework_TestCase, можно переопределить эти методы и поместить повторяющийся ранее в каждом тестовом методе код в них. В результате последовательность вызова методов при прогонке тестов будет следующая:</p>
        
        <!--это менее правильно решение переходов по странице-->
        <a name="bottom"></a>

        <!--это более правильно решение переходов по странице-->
        <a href="#up">up</a>
            
            
            
            
                        
            
            
            
            
            
            
            
    </body>
</html>